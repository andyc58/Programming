Andy Cherney
CIS-501-001

Project #1 Pseudocode



import regex


// take in the user's sentence
String sentence = input("Enter Japanese: \n") 	

// This is the resulting HTML string that will be built			
String HTML = "" 

// This string will be used to extract the Kanji or Kanji sequences in the sentence
String kanji_parts = ""


/*********************************************************************************************************************************************************
The below variables define unicode ranges of Japanese non-kanji characters based on what I researched online. 
I still need to see what these ranges are matching to see if I am overcounting or undercounting the set, 
but these would be used in a regex pattern to check whether a character is a kanji character or not. 
I think a regex pattern would be most efficient for this purpose,since the set of characters is quite large, especially for Kanji. 
Hiragana and Katakana is a way smaller set (around 256 characters including diacritics and digraphs, but still not that easy to keep track of by hand. 

Additionally, one needs to keep track of special and outlier characters as well. 
For instance, Japanese Kana characters can either be 2-bit (full-width) or 1 bit (half-width). 
Another category that should be included is romanized characters (romaji).
These are all the characters found in English, 
and they are used sometimes as a shorthand with Katakana to denote non-native names or in abbreviations (e.g: DVD, GMC). 
**********************************************************************************************************************************************************/

String japanese_special_chars = "[\u3000-\u303f]" // Mainly needed for punctuation marks and other special characters in Japanese
String hiragana = "[\u3040-\u309f]"
String katakana = "[\u30a0-\u30ff]"
String full_romaji_and_half_width = "[\uff00-\uffef]" // Outlier characters

// Possible formatted regex pattern for non_kanji.
String non_kanji_pattern = f"{japanese_special_chars}|{hiragana}|{katakana}|{full_romaji_and_half_width}" 



// Iterate through each character in the sentence. I think in Java, you would need to convert it to a char array first (coming from Python where strings are already iterable)

for (character in sentence.toCharArray()) {


  	// This checks if the character is non-kanji. Fastest way would be through regex pattern matching, but I don't know the function for it in Java
     
	if (regex.match(non_kanji_pattern, character)) {	
        

	/* 
	The next step is to check whether the kanji parts string is not empty. If true, 
	then the program will prompt the user for the annotation and add the annotation with the proper ruby syntax to the result string 
	/*

		if (kanji_parts) { 	
             
	     		furigana = input(f"Annotation for {kanji_parts}: ")
             		HTML += f"<ruby>{kanji_parts}<rt>{furigana}</rt></ruby>"

	
			// When the user is done and the annotation is added to the result string, clear the Kanji part string for the next iteration
        　　　		kanji_parts = ""   					
         
		}
	 
		// Add the non-kanji character to the result after annotation or whenever the Kanji part string is empty (meaning no Kanji found yet in the sentence)
          	HTML += character  

		// Continue to the next iteration once the checks are performed onto the next character		
          	continue  			
	}
	
	//　If the character is a kanji character, add it to the Kanji part string. This will continue until the loop hits a non-Kanji character

    	kanji_parts += character 
}   

// Display the resulting string
print("\nThe full annotation is: \n")
print(HTML)